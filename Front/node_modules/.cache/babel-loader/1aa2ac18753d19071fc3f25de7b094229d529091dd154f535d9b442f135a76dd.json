{"ast":null,"code":"import { FILTER, ORDER, CLEAN_DETAIL, GET_CHARACTER_DETAIL, GET_FAVORITES } from \"./actions\";\nconst initialState = {\n  myFavorites: [],\n  allCharacters: [],\n  characterDetail: {}\n};\nconst reducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let actions = arguments.length > 1 ? arguments[1] : undefined;\n  switch (actions.type) {\n    case CLEAN_DETAIL:\n      return {\n        ...state,\n        characterDetail: {}\n      };\n    // case AGREGAR:\n    //   return {\n    //     ...state,\n    //     myFavorites: [...state.allCharacters, actions.payload], // estamos haciendo un nuevo array con una copia del array allCharacter y sumandole el objeto que es la card favorita..\n    //     allCharacters: [...state.allCharacters, actions.payload], // aca hacemos una copia del array allCharacter y creando un nuevo array...\n    //   };\n    // case ELIMINAR:\n    //   return {\n    //     ...state,\n    //     myFavorites: state.myFavorites.filter(\n    //       (pars) => pars.id !== actions.payload\n    //     ),\n    //   };\n    case FILTER:\n      return {\n        ...state,\n        myFavorites: state.allCharacters.filter(pars => pars.gender === actions.payload)\n      };\n    case ORDER:\n      return {\n        ...state,\n        // si algunos de los casos se cumplio myFavorites pasa a ser el array modificado y ordenado... [id 1 , id 2 , id3] , luego en el componente Favorites.jsx recorro este array y voy renderizando cada personaje en base a su orden...\n        myFavorites: actions.payload === \"Descendente\" ? [...state.allCharacters].sort((a, b) => b.id - a.id) // si b es menor al a ===> decendente..\n        : [...state.allCharacters].sort((a, b) => a.id - b.id) // si a es menor a b ===> acendente... y el metodo sort devuelve un nuevo array con los elementos ordenados..\n      };\n\n    default:\n      return {\n        ...state\n      };\n  }\n};\nexport default reducer;","map":{"version":3,"names":["FILTER","ORDER","CLEAN_DETAIL","GET_CHARACTER_DETAIL","GET_FAVORITES","initialState","myFavorites","allCharacters","characterDetail","reducer","state","arguments","length","undefined","actions","type","filter","pars","gender","payload","sort","a","b","id"],"sources":["C:/Users/Usuario/OneDrive/Escritorio/rick_and_morty/Front/src/redux/reducer.js"],"sourcesContent":["import {\r\n  FILTER,\r\n  ORDER,\r\n  CLEAN_DETAIL,\r\n  GET_CHARACTER_DETAIL,\r\n  GET_FAVORITES,\r\n} from \"./actions\";\r\n\r\nconst initialState = {\r\n  myFavorites: [],\r\n  allCharacters: [],\r\n  characterDetail: {},\r\n};\r\n\r\nconst reducer = (state = initialState, actions) => {\r\n  switch (actions.type) {\r\n    case CLEAN_DETAIL:\r\n      return {\r\n        ...state,\r\n        characterDetail: {},\r\n      };\r\n    // case AGREGAR:\r\n    //   return {\r\n    //     ...state,\r\n    //     myFavorites: [...state.allCharacters, actions.payload], // estamos haciendo un nuevo array con una copia del array allCharacter y sumandole el objeto que es la card favorita..\r\n    //     allCharacters: [...state.allCharacters, actions.payload], // aca hacemos una copia del array allCharacter y creando un nuevo array...\r\n    //   };\r\n    // case ELIMINAR:\r\n    //   return {\r\n    //     ...state,\r\n    //     myFavorites: state.myFavorites.filter(\r\n    //       (pars) => pars.id !== actions.payload\r\n    //     ),\r\n    //   };\r\n    case FILTER:\r\n      return {\r\n        ...state,\r\n        myFavorites: state.allCharacters.filter(\r\n          (pars) => pars.gender === actions.payload\r\n        ),\r\n      };\r\n    case ORDER:\r\n      return {\r\n        ...state,\r\n\r\n        // si algunos de los casos se cumplio myFavorites pasa a ser el array modificado y ordenado... [id 1 , id 2 , id3] , luego en el componente Favorites.jsx recorro este array y voy renderizando cada personaje en base a su orden...\r\n        myFavorites:\r\n          actions.payload === \"Descendente\"\r\n            ? [...state.allCharacters].sort((a, b) => b.id - a.id) // si b es menor al a ===> decendente..\r\n            : [...state.allCharacters].sort((a, b) => a.id - b.id), // si a es menor a b ===> acendente... y el metodo sort devuelve un nuevo array con los elementos ordenados..\r\n      };\r\n    default:\r\n      return { ...state };\r\n  }\r\n};\r\n\r\nexport default reducer;\r\n"],"mappings":"AAAA,SACEA,MAAM,EACNC,KAAK,EACLC,YAAY,EACZC,oBAAoB,EACpBC,aAAa,QACR,WAAW;AAElB,MAAMC,YAAY,GAAG;EACnBC,WAAW,EAAE,EAAE;EACfC,aAAa,EAAE,EAAE;EACjBC,eAAe,EAAE,CAAC;AACpB,CAAC;AAED,MAAMC,OAAO,GAAG,SAAAA,CAAA,EAAmC;EAAA,IAAlCC,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGN,YAAY;EAAA,IAAES,OAAO,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAC5C,QAAQC,OAAO,CAACC,IAAI;IAClB,KAAKb,YAAY;MACf,OAAO;QACL,GAAGQ,KAAK;QACRF,eAAe,EAAE,CAAC;MACpB,CAAC;IACH;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAKR,MAAM;MACT,OAAO;QACL,GAAGU,KAAK;QACRJ,WAAW,EAAEI,KAAK,CAACH,aAAa,CAACS,MAAM,CACpCC,IAAI,IAAKA,IAAI,CAACC,MAAM,KAAKJ,OAAO,CAACK,OAAO;MAE7C,CAAC;IACH,KAAKlB,KAAK;MACR,OAAO;QACL,GAAGS,KAAK;QAER;QACAJ,WAAW,EACTQ,OAAO,CAACK,OAAO,KAAK,aAAa,GAC7B,CAAC,GAAGT,KAAK,CAACH,aAAa,CAAC,CAACa,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACC,EAAE,GAAGF,CAAC,CAACE,EAAE,CAAC,CAAC;QAAA,EACrD,CAAC,GAAGb,KAAK,CAACH,aAAa,CAAC,CAACa,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,EAAE,GAAGD,CAAC,CAACC,EAAE,CAAC,CAAE;MAC9D,CAAC;;IACH;MACE,OAAO;QAAE,GAAGb;MAAM,CAAC;EAAC;AAE1B,CAAC;AAED,eAAeD,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}